'use strict';
const Injector = require('injector');
const _ = require('lodash');
var Q = require('q');

module.exports = Injector.define([
    'component/mongodb',
    'config/mongodb_task_manager'
], createModule);

function createModule(mongodb, taskManagerConfig) {
    return _.mapValues(taskManagerConfig, config => {
        const collectionPromise = mongodb[config.mongodbInstanceName].then(db => {
            return db.collection(config.collectionName);
        });

        const TASK_STATE = {
            NEW: 1,
            RENEW: 2,
            PENDING: 3,
            END: 4
        };

        class TaskManager {
            constructor(managerId) {
                this.managerId = managerId;
            }

            isEmpty() {
                return collectionPromise.then(collection => {
                    const filter = {
                        taskType: config.taskType
                    };
                    return collection.find(filter).limit(1).toArray().then(tasks => {
                        return tasks.length <= 0;
                    });
                });
            }

            viewTask(taskId) {
                return collectionPromise.then(collection => {
                    const filter = {
                        _id: taskId,
                        taskType: config.taskType
                    };
                    return collection.find(filter).limit(1).toArray().then(mongodb.pickOneDoc());
                });
            }

            viewAvailableTasks(limit) {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const filter = {
                        taskType: config.taskType,
                        taskState: {
                            $in: [TASK_STATE.NEW, TASK_STATE.RENEW, TASK_STATE.PENDING]
                        },
                        expired: {
                            $lt: now
                        }
                    };
                    const sort = {
                        expired: 1
                    };
                    return Q(limit).then(limit => {
                        if (limit) {
                            return collection.find(filter).sort(sort).limit(limit).toArray();
                        } else {
                            return collection.find(filter).sort(sort).toArray();
                        }
                    });
                });
            }

            viewAvailableEarliestTask() {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const filter = {
                        taskType: config.taskType,
                        taskState: {
                            $in: [TASK_STATE.NEW, TASK_STATE.RENEW, TASK_STATE.PENDING]
                        },
                        expired: {
                            $lt: now
                        }
                    };
                    const sort = {
                        expired: 1
                    };
                    return collection.find(filter).sort(sort).limit(1).toArray().then(mongodb.pickOneDoc());
                });
            }

            viewAvailableLatestTask() {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const filter = {
                        taskType: config.taskType,
                        taskState: {
                            $in: [TASK_STATE.NEW, TASK_STATE.RENEW, TASK_STATE.PENDING]
                        },
                        expired: {
                            $lt: now
                        }
                    };
                    const sort = {
                        expired: -1
                    };
                    return collection.find(filter).sort(sort).limit(1).toArray(mongodb.pickOneDoc());
                });
            }

            viewLatestEndTask() {
                return collectionPromise.then(collection => {
                    const filter = {
                        taskType: config.taskType,
                        taskState: TASK_STATE.END
                    };
                    const sort = {
                        expired: -1
                    };
                    return collection.find(filter).sort(sort).limit(1).toArray(mongodb.pickOneDoc());
                });
            }

            viewTasks(limit) {
                return collectionPromise.then(collection => {
                    const filter = {
                        taskType: config.taskType
                    };
                    const sort = {
                        expired: 1
                    };
                    return Q(limit).then(limit => {
                        if (limit) {
                            return collection.find(filter).sort(sort).limit(limit).toArray();
                        } else {
                            return collection.find(filter).sort(sort).toArray();
                        }
                    });
                });
            }

            newTask(taskId, delay, data) {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const task = {
                        _id: taskId,
                        taskType: config.taskType,
                        taskState: TASK_STATE.NEW,
                        expired: now + delay,
                        attempt: 0,
                        data: data,
                        created: now
                    };
                    return collection.insertOne(task).then(mongodb.resultInsertId);
                });
            }

            beginTask(taskId, timeout) {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const filter = {
                        _id: taskId,
                        taskType: config.taskType,
                        taskState: {
                            $in: [TASK_STATE.NEW, TASK_STATE.RENEW, TASK_STATE.PENDING]
                        },
                        expired: {
                            $lt: now
                        }
                    };
                    const task = {
                        $set: {
                            taskState: TASK_STATE.PENDING,
                            expired: now + timeout,
                            managerId: this.managerId
                        },
                        $inc: {
                            attempt: 1
                        }
                    };
                    return collection.findOneAndUpdate(filter, task, {returnOriginal: false}).then(result => {
                        return result.value;
                    });
                });
            }

            tryBeginTask(tasks, timeout, fromIndex = 0) {
                if (fromIndex >= tasks.length) {
                    return Q.resolve();
                }
                return this.beginTask(tasks[fromIndex]._id, timeout).then(task => {
                    if (task) {
                        return task;
                    }
                    return this.tryBeginTask(tasks, timeout, fromIndex + 1);
                });
            }

            tryBeginAvailableTask(timeout, limit) {
                return this.viewAvailableTasks(limit).then(tasks => {
                    return this.tryBeginTask(tasks, timeout);
                });
            }

            tryBeginTheFocusTask(timeout) {
                return collectionPromise.then(collection => {

                    const filterEnd = {
                        taskType: config.taskType,
                        taskState: TASK_STATE.END
                    };
                    const filterPending = {
                        taskType: config.taskType,
                        taskState: TASK_STATE.END
                    };
                    const filterNewAndReNew = {
                        taskType: config.taskType,
                        taskState: {
                            $in: [TASK_STATE.NEW, TASK_STATE.RENEW]
                        }
                    };
                    const orderAsc = {
                        expired: 1
                    };
                    const orderDsc = {
                        expired: -1
                    };
                    return Q.all([
                        collection.find(filterEnd).sort(orderDsc).limit(1).then(mongodb.pickOneDoc()),
                        collection.find(filterPending).sort(orderAsc).limit(1).then(mongodb.pickOneDoc()),
                        collection.find(filterNewAndReNew).sort(orderAsc).limit(1).then(mongodb.pickOneDoc())
                    ]).spread((taskEnd, taskPending, taskNew) => {
                        if (taskPending) {
                            return this.beginTask(taskPending._id, timeout);
                        } else if (taskEnd) {
                            if ('nextTaskId' in taskEnd) {
                                return this.beginTask(taskEnd.nextTaskId, timeout);
                            } else if (taskNew) {
                                const filter = {
                                    _id: taskEnd._id,
                                    taskType: config.taskType,
                                    taskState: TASK_STATE.END,
                                    nextTaskId: {
                                        $exists: false
                                    }
                                };
                                const update = {
                                    $set: {
                                        nextTaskId: taskNew._id
                                    }
                                };
                                return collection.updateOne(filter, update).then(mongodb.resultModifiedN).then(n => {
                                    if (n) {
                                        return this.beginTask(taskNew._id, timeout);
                                    }
                                });
                            }
                        } else if (taskNew) {
                            return this.beginTask(taskNew._id, timeout);
                        }
                    });
                });
            }

            endTask(taskId, data) {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const filter = {
                        _id: taskId,
                        taskType: config.taskType,
                        taskState: TASK_STATE.PENDING,
                        expired: {
                            $gte: now
                        },
                        managerId: this.managerId
                    };
                    const task = {
                        $set: {
                            taskState: TASK_STATE.END,
                            expired: now,
                            data: data
                        },
                        $unset: {
                            managerId: true
                        }
                    };
                    return collection.findOneAndUpdate(filter, task, {returnOriginal: false}).then(result => {
                        return result.value;
                    });
                });
            }

            endAndAssignNextTask(taskId, nextTaskId, data) {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const filter = {
                        _id: taskId,
                        taskType: config.taskType,
                        taskState: TASK_STATE.PENDING,
                        expired: {
                            $gte: now
                        },
                        managerId: this.managerId
                    };
                    const task = {
                        $set: {
                            taskState: TASK_STATE.END,
                            expired: now,
                            data: data,
                            nextTaskId: nextTaskId
                        },
                        $unset: {
                            managerId: true
                        }
                    };
                    return collection.findOneAndUpdate(filter, task, {returnOriginal: false}).then(result => {
                        return result.value;
                    });
                });
            }

            endAndReNewTask(taskId, delay, data) {
                return collectionPromise.then(collection => {
                    const now = Date.now();
                    const filter = {
                        _id: taskId,
                        taskType: config.taskType,
                        taskState: TASK_STATE.PENDING,
                        expired: {
                            $gte: now
                        },
                        managerId: this.managerId
                    };
                    const task = {
                        $set: {
                            taskState: TASK_STATE.RENEW,
                            expired: now + delay,
                            data: data
                        },
                        $unset: {
                            managerId: true
                        }
                    };
                    return collection.findOneAndUpdate(filter, task, {returnOriginal: false}).then(result => {
                        return result.value;
                    });
                });
            }
        }

        return {TaskManager, TASK_STATE};
    });
}
